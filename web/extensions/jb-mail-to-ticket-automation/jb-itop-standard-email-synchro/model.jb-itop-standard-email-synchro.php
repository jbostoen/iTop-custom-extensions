						<?php
//
// File generated by ... on the 2019-10-04T15:45:46+0200
// Please do not edit manually
//

/**
 * Classes and menus for jb-itop-standard-email-synchro (version 2.6.190803)
 *
 * @author      iTop compiler
 * @license     http://opensource.org/licenses/AGPL-3.0
 */



class MailInboxStandard extends MailInboxBase
{
	public static function Init()
	{
		$aParams = array(			'category' => 'searchable,view_in_gui,bizmodel',
			'key_type' => 'autoincrement',
			'name_attcode' => array('login'),
			'state_attcode' => '',
			'reconc_keys' => array('server', 'login', 'protocol', 'mailbox', 'port'),
			'db_table' => 'mailinbox_standard',
			'db_key_field' => 'id',
			'db_finalclass_field' => 'realclass',
			'icon' => utils::GetAbsoluteUrlModulesRoot().'jb-itop-standard-email-synchro/images/mailbox.png',);
		MetaModel::Init_Params($aParams);
		MetaModel::Init_InheritAttributes();
		MetaModel::Init_AddAttribute(new AttributeEnum("behavior", array("allowed_values"=>new ValueSetEnum("create_only,update_only,both"), "display_style"=>'list', "sql"=>'behavior', "default_value"=>'both', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("target_class", array("allowed_values"=>new ValueSetEnum("Incident,UserRequest,Change,RoutineChange,NormalChange,EmergencyChange,Problem"), "display_style"=>'list', "sql"=>'target_class', "default_value"=>'UserRequest', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeText("ticket_default_values", array("allowed_values"=>null, "sql"=>'ticket_default_values', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("title_pattern", array("allowed_values"=>null, "sql"=>'title_pattern', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("error_behavior", array("allowed_values"=>new ValueSetEnum("delete,mark_as_error"), "display_style"=>'list', "sql"=>'error_behavior', "default_value"=>'mark_as_error', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEmailAddress("notify_errors_to", array("allowed_values"=>null, "sql"=>'notify_errors_to', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEmailAddress("notify_from", array("allowed_values"=>null, "sql"=>'notify_from', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeText("mail_aliases", array("allowed_values"=>null, "sql"=>'mail_aliases', "default_value"=>'', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("trace", array("allowed_values"=>new ValueSetEnum("yes,no"), "display_style"=>'list', "sql"=>'trace', "default_value"=>'no', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeLongText("debug_trace", array("allowed_values"=>null, "sql"=>'debug_trace', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("email_storage", array("allowed_values"=>new ValueSetEnum("keep,delete"), "display_style"=>'list', "sql"=>'email_storage', "default_value"=>'keep', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeText("stimuli", array("allowed_values"=>null, "sql"=>'stimuli', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("policy_mail_size_too_big_behavior", array("allowed_values"=>new ValueSetEnum("mark_as_undesired,delete,bounce_delete,bounce_mark_as_undesired"), "display_style"=>'list', "sql"=>'policy_mail_size_too_big_behavior', "default_value"=>'bounce_delete', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("policy_mail_size_too_big_subject", array("allowed_values"=>null, "sql"=>'policy_mail_size_too_big_subject', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeHTML("policy_mail_size_too_big_notification", array("allowed_values"=>null, "sql"=>'policy_mail_size_too_big_notification', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("policy_mail_size_too_big_max_size_MB", array("allowed_values"=>null, "sql"=>'policy_mail_size_too_big_max_size_MB', "default_value"=>'10', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("policy_forbidden_attachments_behavior", array("allowed_values"=>new ValueSetEnum("fallback,mark_as_undesired,delete,bounce_delete,bounce_mark_as_undesired"), "display_style"=>'list', "sql"=>'policy_forbidden_attachments_behavior', "default_value"=>'bounce_delete', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("policy_forbidden_attachments_subject", array("allowed_values"=>null, "sql"=>'policy_forbidden_attachments_subject', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeHTML("policy_forbidden_attachments_notification", array("allowed_values"=>null, "sql"=>'policy_forbidden_attachments_notification', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeText("policy_forbidden_attachments_mimetypes", array("allowed_values"=>null, "sql"=>'policy_forbidden_attachments_mimetypes', "default_value"=>'application/exe', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("policy_no_subject_behavior", array("allowed_values"=>new ValueSetEnum("fallback,mark_as_undesired,delete,bounce_delete,bounce_mark_as_undesired"), "display_style"=>'list', "sql"=>'policy_no_subject_behavior', "default_value"=>'fallback', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("policy_no_subject_subject", array("allowed_values"=>null, "sql"=>'policy_no_subject_subject', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeHTML("policy_no_subject_notification", array("allowed_values"=>null, "sql"=>'policy_no_subject_notification', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("policy_no_subject_default_value", array("allowed_values"=>null, "sql"=>'policy_no_subject_default_value', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("policy_unknown_caller_behavior", array("allowed_values"=>new ValueSetEnum("fallback,mark_as_undesired,delete,bounce_delete,bounce_mark_as_undesired"), "display_style"=>'list', "sql"=>'policy_unknown_caller_behavior', "default_value"=>'bounce_delete', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("policy_unknown_caller_subject", array("allowed_values"=>null, "sql"=>'policy_unknown_caller_subject', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeHTML("policy_unknown_caller_notification", array("allowed_values"=>null, "sql"=>'policy_unknown_caller_notification', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeText("policy_unknown_caller_default_values", array("allowed_values"=>null, "sql"=>'policy_unknown_caller_default_values', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("policy_other_recipients_behavior", array("allowed_values"=>new ValueSetEnum("add_existing_contacts,add_all_contacts,ignore_all_contacts,mark_as_undesired,delete,bounce_delete,bounce_mark_as_undesired"), "display_style"=>'list', "sql"=>'policy_other_recipients_behavior', "default_value"=>'bounce_delete', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("policy_other_recipients_subject", array("allowed_values"=>null, "sql"=>'policy_other_recipients_subject', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeHTML("policy_other_recipients_notification", array("allowed_values"=>null, "sql"=>'policy_other_recipients_notification', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeText("policy_other_recipients_default_values", array("allowed_values"=>null, "sql"=>'policy_other_recipients_default_values', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("policy_ticket_closed_behavior", array("allowed_values"=>new ValueSetEnum("fallback,mark_as_undesired,delete,bounce_delete,bounce_mark_as_undesired"), "display_style"=>'list', "sql"=>'policy_ticket_closed_behavior', "default_value"=>'bounce_delete', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("policy_ticket_closed_subject", array("allowed_values"=>null, "sql"=>'policy_ticket_closed_subject', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeHTML("policy_ticket_closed_notification", array("allowed_values"=>null, "sql"=>'policy_ticket_closed_notification', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("policy_ticket_resolved_behavior", array("allowed_values"=>new ValueSetEnum("fallback,mark_as_undesired,delete,bounce_delete,bounce_mark_as_undesired"), "display_style"=>'list', "sql"=>'policy_ticket_resolved_behavior', "default_value"=>'bounce_delete', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("policy_ticket_resolved_subject", array("allowed_values"=>null, "sql"=>'policy_ticket_resolved_subject', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeHTML("policy_ticket_resolved_notification", array("allowed_values"=>null, "sql"=>'policy_ticket_resolved_notification', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("policy_ticket_unknown_behavior", array("allowed_values"=>new ValueSetEnum("mark_as_undesired,delete,bounce_delete,bounce_mark_as_undesired"), "display_style"=>'list', "sql"=>'policy_ticket_unknown_behavior', "default_value"=>'bounce_delete', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("policy_ticket_unknown_subject", array("allowed_values"=>null, "sql"=>'policy_ticket_unknown_subject', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeHTML("policy_ticket_unknown_notification", array("allowed_values"=>null, "sql"=>'policy_ticket_unknown_notification', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("policy_undesired_pattern_behavior", array("allowed_values"=>new ValueSetEnum("mark_as_undesired,delete,bounce_delete,bounce_mark_as_undesired"), "display_style"=>'list', "sql"=>'policy_undesired_pattern_behavior', "default_value"=>'delete', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeString("policy_undesired_pattern_subject", array("allowed_values"=>null, "sql"=>'policy_undesired_pattern_subject', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeHTML("policy_undesired_pattern_notification", array("allowed_values"=>null, "sql"=>'policy_undesired_pattern_notification', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeText("policy_undesired_pattern_patterns", array("allowed_values"=>null, "sql"=>'policy_undesired_pattern_patterns', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeEnum("policy_remove_pattern_behavior", array("allowed_values"=>new ValueSetEnum("ignore,delete"), "display_style"=>'list', "sql"=>'policy_remove_pattern_behavior', "default_value"=>'ignore', "is_null_allowed"=>false, "depends_on"=>array(), "always_load_in_tables"=>false)));
		MetaModel::Init_AddAttribute(new AttributeText("policy_remove_pattern_patterns", array("allowed_values"=>null, "sql"=>'policy_remove_pattern_patterns', "default_value"=>'', "is_null_allowed"=>true, "depends_on"=>array(), "always_load_in_tables"=>false)));



		MetaModel::Init_SetZListItems('details', array (
  'fieldset:MailInbox:Server' => 
  array (
    0 => 'server',
    1 => 'login',
    2 => 'password',
    3 => 'protocol',
    4 => 'port',
    5 => 'mailbox',
    6 => 'notify_from',
    7 => 'active',
    8 => 'trace',
    9 => 'mail_aliases',
  ),
  'fieldset:MailInbox:Behavior' => 
  array (
    0 => 'behavior',
    1 => 'email_storage',
    2 => 'target_class',
    3 => 'ticket_default_values',
    4 => 'title_pattern',
    5 => 'stimuli',
  ),
  'fieldset:MailInbox:Errors' => 
  array (
    0 => 'error_behavior',
    1 => 'notify_errors_to',
  ),
  'fieldset:MailInbox:PolicyMailSize' => 
  array (
    0 => 'policy_mail_size_too_big_behavior',
    1 => 'policy_mail_size_too_big_subject',
    2 => 'policy_mail_size_too_big_notification',
    3 => 'policy_mail_size_too_big_max_size_MB',
  ),
  'fieldset:MailInbox:PolicyForbiddenAttachments' => 
  array (
    0 => 'policy_forbidden_attachments_behavior',
    1 => 'policy_forbidden_attachments_subject',
    2 => 'policy_forbidden_attachments_notification',
    3 => 'policy_forbidden_attachments_mimetypes',
  ),
  'fieldset:MailInbox:PolicyNoSubject' => 
  array (
    0 => 'policy_no_subject_behavior',
    1 => 'policy_no_subject_subject',
    2 => 'policy_no_subject_notification',
    3 => 'policy_no_subject_default_value',
  ),
  'fieldset:MailInbox:PolicyClosedTicket' => 
  array (
    0 => 'policy_ticket_closed_behavior',
    1 => 'policy_ticket_closed_subject',
    2 => 'policy_ticket_closed_notification',
  ),
  'fieldset:MailInbox:PolicyResolvedTicket' => 
  array (
    0 => 'policy_ticket_resolved_behavior',
    1 => 'policy_ticket_resolved_subject',
    2 => 'policy_ticket_resolved_notification',
  ),
  'fieldset:MailInbox:PolicyUnknownTicket' => 
  array (
    0 => 'policy_ticket_unknown_behavior',
    1 => 'policy_ticket_unknown_subject',
    2 => 'policy_ticket_unknown_notification',
  ),
  'fieldset:MailInbox:PolicyUnknownCaller' => 
  array (
    0 => 'policy_unknown_caller_behavior',
    1 => 'policy_unknown_caller_subject',
    2 => 'policy_unknown_caller_notification',
    3 => 'policy_unknown_caller_default_values',
  ),
  'fieldset:MailInbox:PolicyOtherRecipients' => 
  array (
    0 => 'policy_other_recipients_behavior',
    1 => 'policy_other_recipients_subject',
    2 => 'policy_other_recipients_notification',
  ),
  'fieldset:MailInbox:PolicyUndesiredPattern' => 
  array (
    0 => 'policy_undesired_pattern_behavior',
    1 => 'policy_undesired_pattern_subject',
    2 => 'policy_undesired_pattern_notification',
    3 => 'policy_undesired_pattern_patterns',
  ),
  'fieldset:MailInbox:PolicyIgnoreRemovePattern' => 
  array (
    0 => 'policy_remove_pattern_behavior',
    1 => 'policy_remove_pattern_patterns',
  ),
));
		MetaModel::Init_SetZListItems('standard_search', array (
  0 => 'server',
  1 => 'login',
  2 => 'mailbox',
  3 => 'protocol',
  4 => 'active',
));
		MetaModel::Init_SetZListItems('list', array (
  0 => 'server',
  1 => 'mailbox',
  2 => 'protocol',
  3 => 'active',
));
;
	}


	/**
	 * Add an extra tab showing the debug trace
	 * @see cmdbAbstractObject::DisplayBareRelations()
	 */
	function DisplayBareRelations(WebPage $oPage, $bEditMode = false)
	{
		parent::DisplayBareRelations($oPage, $bEditMode);
		if (!$bEditMode)
		{
			$oPage->SetCurrentTab(Dict::S('MailInboxStandard:DebugTrace'));
			$sAjaxUrl = addslashes(utils::GetAbsoluteUrlModulesRoot().basename(dirname(__FILE__)).'/ajax.php');
			$iId = $this->GetKey();
			if ($this->Get('trace') == 'yes')
			{
				$oPage->add('<p><button type="button" id="debug_trace_refresh">'.Dict::S('UI:Button:Refresh').'</button></p>');
				$oPage->add('<div id="debug_trace_output"></div>');
				$oPage->add_ready_script(
<<<EOF
$('#debug_trace_refresh').click(function() {
	$('#debug_trace_output').html('<img src="../images/indicator.gif"/>');
	$.post('$sAjaxUrl', {operation: 'debug_trace', id: $iId }, function(data) {
		$('#debug_trace_output').html(data);
	});
});
$('#debug_trace_refresh').trigger('click');
EOF
				);
			}
			else
			{
				$oPage->add('<div id="debug_trace_output"><p>'.Dict::S('MailInboxStandard:DebugTraceNotActive').'</p></div>');
			}
		}
	}

	/**
	 * Debug trace: activated/disabled by the configuration flag set for the base module...
	 * @param string $sText
	 */
	protected function Trace($sText)
	{
		parent::Trace($sText);
		$iMaxTraceLength = 500*1024; // Maximum size of the Trace to keep in the database...
		
		if ($this->Get('trace') == 'yes')
		{
			$sStampedText = date('Y-m-d H:i:s').' - '.$sText."\n";
			$this->Set('debug_trace', $sStampedText.substr($this->Get('debug_trace'), -$iMaxTraceLength));

			// Creating a CMDBChange is no longer needed in 2.0, but let's keep doing it for compatibility with 1.x
			$oMyChange = MetaModel::NewObject("CMDBChange");
			$oMyChange->Set("date", time());
			$sUserString = CMDBChange::GetCurrentUserName();
			$oMyChange->Set("userinfo", $sUserString);
			$iChangeId = $oMyChange->DBInsert();
			$this->DBUpdateTracked($oMyChange);
		}
	}


	protected function RecordAttChanges(array $aValues, array $aOrigValues)
	{
		// Do NOT record the changes on the 'debug trace' attribute
		unset($aValues['debug_trace']);
		parent::RecordAttChanges($aValues, $aOrigValues);
	}

	/**
	 * Initial dispatching of an incoming email: determines what to do with the email
	 * @param EmailReplica $oEmailReplica The EmailReplica associated with the email. A new replica (i.e. not yet in DB) one for new emails
	 * @return int An action code from EmailProcessor
	 */
		public function DispatchEmail(EmailReplica $oEmailReplica)
	{
	
		return parent::DispatchEmail($oEmailReplica);
						  
	}
		

	/**
	 * Process an new (unread) incoming email
	 * @param EmailSource $oSource The source from which this email was read
	 * @param int $index The index of the message in the source
	 * @param EmailMessage $oEmail The decoded email
	 * @return Ticket The ticket created or updated in response to the email
	 */
	public function ProcessNewEmail(EmailSource $oSource, $index, EmailMessage $oEmail)
	{		
		$this->Trace("Processing new eMail ( index = $index )"); 
		$this->Trace(". UIDL ".htmlspecialchars($oEmail->sUIDL) );
		$this->Trace(". Message-ID ".htmlspecialchars ($oEmail->sMessageId) );
				
		// Contrary to Combodo: First check if there is any iTop object mentioned in the headers of the eMail
		// We will be handling null values and closed/resolved tickets in policy checks.
        // Check whether we need to create a new ticket or to update an existing one
		// This is more thorough than the parent method
        $oTicket = $this->GetRelatedTicket($oEmail);

		
		// Careful: Combodo's version implemented an IsUndesired-method in later versions (v3.0.11).
		// Our method needs an additional parameter ( $oTicket ) to validate the email against some policies.
		$oPolicy = $this->IsUndesired($oEmail, $oTicket);
		
		// Not policy compliant? Then stop processing. 
		if( $oPolicy->bUndesired ) {
			$this->Trace(". Email does not comply with at least one policy ({$oPolicy->sPolicyId}) - so undesired.");
			$this->HandlePolicyViolation($oEmail, $oPolicy->sPolicyId, $oEmail->oRawEmail);
			return null;
		}
		else {
			$this->Trace(". Email complies with specified policies.");
		}
		 
		$oCaller = $oPolicy->oCaller;
		 

		switch($this->Get('behavior'))
		{
			case 'create_only':
				$oTicket = $this->CreateTicketFromEmail($oEmail, $oCaller);
				break;
			
			case 'update_only':
				if (!is_object($oTicket))
				{
					// No ticket associated with the incoming email, nothing to update, reject the email
					$this->HandleError($oEmail, 'nothing_to_update', $oEmail->oRawEmail);
				}
				else
				{
					// Update the ticket with the incoming eMail
					$this->UpdateTicketFromEmail($oTicket, $oEmail, $oCaller);
				}
				break;
			
			default: // both: update or create as needed
				if (!is_object($oTicket))
				{
					// Let's create a new ticket
					$oTicket = $this->CreateTicketFromEmail($oEmail, $oCaller);
				}
				else
				{
					// Update the ticket with the incoming eMail
					$this->UpdateTicketFromEmail($oTicket, $oEmail, $oCaller);
				}
				break;			
		}
		
		return $oTicket;
	}

	/**
	 * Search if the caller email is an existing contact in iTop, if not may create it
	 * depending on the mailinbox setting.
	 * {@inheritDoc}
	 * @see MailInboxBase::FindCaller()
	 */
	protected function FindCaller(EmailMessage $oEmail)
	{
		$oCaller = null;
		$sContactQuery = 'SELECT Person WHERE email = :email';
		$oSet = new DBObjectSet(DBObjectSearch::FromOQL($sContactQuery), array(), array('email' => $oEmail->sCallerEmail));
		$sAdditionalDescription = '';
		switch($oSet->Count())
		{
			case 1:
				// Ok, the caller was found in iTop
				$oCaller = $oSet->Fetch();
				break;
				
			case 0:
			
				switch($this->Get('policy_unknown_caller_behavior'))
				{
					case 'bounce_delete': 
					case 'bounce_mark_as_undesired':
					case 'delete':
					case 'mark_as_undesired':
						// Policy violation
						$this->Trace("No contact found for the email address '{$oEmail->sCallerEmail}', the email will not be processed.");
						$this->HandlePolicyViolation($oEmail, 'policy_unknown_caller', $oEmail->oRawEmail);
						return null;
						break;
					
					case 'fallback':
					default:
						$this->Trace("Creating a new Person for the email: {$oEmail->sCallerEmail}");
						$oCaller = new Person();
						$oCaller->Set('email', $oEmail->sCallerEmail);
						$sDefaultValues = $this->Get('policy_unknown_caller_default_values');
						$aDefaults = explode("\n", $sDefaultValues);
						$aDefaultValues = array();
						foreach($aDefaults as $sLine)														   
						{
							if (preg_match('/^([^:]+):(.*)$/', $sLine, $aMatches))
							{
								$sAttCode = trim($aMatches[1]);
								$sValue = trim($aMatches[2]);
								$aDefaultValues[$sAttCode] = $sValue;
							}
						}
						$this->InitObjectFromDefaultValues($oCaller, $aDefaultValues);
						try
						{
							$this->Trace("Try to create user with default values");
							// Creating a CMDBChange is no longer needed in 2.0, but let's keep doing it for compatibility with 1.x
							$oMyChange = MetaModel::NewObject("CMDBChange");
							$oMyChange->Set("date", time());
							$sUserString = CMDBChange::GetCurrentUserName();
							$oMyChange->Set("userinfo", $sUserString);
							$iChangeId = $oMyChange->DBInsert();
							$oCaller->DBInsertTracked($oMyChange);					
						}
						catch(Exception $e)
						{
							// This is an actual error.
							$this->Trace("Failed to create a Person for the email address '{$oEmail->sCallerEmail}'.");
							$this->Trace($e->getMessage());
							$this->HandleError($oEmail, 'failed_to_create_contact', $oEmail->oRawEmail);
							return null;
						}
					
				}			
				break;
			
			default:
				$this->Trace("Found ".$oSet->Count()." callers with the same email address '{$oEmail->sCallerEmail}', the first one will be used...");
				// Multiple callers with the same email address !!!
				$oCaller = $oSet->Fetch();
		}
		
		return $oCaller;
	}

	/**
	 * 
	 * {@inheritDoc}
	 * @see MailInboxBase::GetRelatedTicket()
	 */
	protected function GetRelatedTicket(EmailMessage $oEmail)
	{
		// First check if there is any iTop object mentioned in the headers of the eMail
		$oTicket = parent::GetRelatedTicket($oEmail);
		
		if ( $oTicket == null )
		{
			// No associated ticket found by parsing the headers, check
			// if the subject does not match a specific pattern
			$sPattern = $this->FixPattern($this->Get('title_pattern'));
			
			// To find the reference, make sure subject is handled in same way as original ticket (removing unwanted pattern)
			$sSubject = $oEmail->sSubject;
			$aRemoveTitlePatterns = explode('/\\r\\n|\\r|\\n/', $this->Get('policy_remove_pattern_patterns'));
			
			foreach( $aRemoveTitlePatterns as $sRemoveTitlePattern ) {
				$oPregMatch = @preg_match($sRemoveTitlePattern, $sSubject);
				
				if( $oPregMatch === false) {
					$this->Trace("... Invalid pattern: {$sRemoveTitlePattern}");
					break;
				}
				elseif( $oPregMatch != false ) {
					$sSubject = preg_replace($sRemoveTitlePattern, '', $sSubject);
				}
				
			}
			
			if(($sPattern != '') && (preg_match($sPattern, $sSubject, $aMatches)))
			{
				$iTicketId = 0;
				sscanf($aMatches[1], '%d', $iTicketId);
				$this->Trace("iTop Simple Email Synchro: Retrieving ticket {$iTicketId} (match by subject pattern)...");
				$oTicket = MetaModel::GetObject('Ticket', $iTicketId, false);
			}
		}		
		
		return $oTicket;
	}

	/**
	 * Actual creation of the ticket from the incoming email. Overload this method
	 * to implement your own behavior, if needed
	 *
	 * @param EmailMessage $oEmail The decoded incoming email
	 * @param Contact $oCaller The contact corresponding to the "From" email address
	 *
	 * @return Ticket the created ticket or null in case of failure
	 * @throws \Exception if invalid target_class
	 */
	public function CreateTicketFromEmail(EmailMessage $oEmail, Contact $oCaller)
	{
		// In case of error (exception...) set the behavior
		if ($this->Get('error_behavior') == 'delete')
		{
			$this->SetNextAction(EmailProcessor::DELETE_MESSAGE); // Remove the message from the mailbox
		}
		else
		{
			$this->SetNextAction(EmailProcessor::MARK_MESSAGE_AS_ERROR); // Keep the message in the mailbox, but marked as error
		}
		$this->Trace("Creating a new Ticket from eMail {$oEmail->sSubject}");
		if (!MetaModel::IsValidClass($this->Get('target_class')))
		{
			$sTargetClass = $this->Get('target_class');
			throw new Exception('Invalid "ticket_class" configured: {$sTargetClass} is not a valid class. Cannot create such an object.');
		}
		$oTicket = MetaModel::NewObject($this->Get('target_class'));
		$oTicket->Set('org_id', $oCaller->Get('org_id'));
		if (MetaModel::IsValidAttCode(get_class($oTicket), 'caller_id'))
		{
			$oTicket->Set('caller_id', $oCaller->GetKey());
		}
		if (MetaModel::IsValidAttCode(get_class($oTicket), 'origin'))
		{
			$oTicket->Set('origin', 'mail');
		}
		
		// Email has no subject. If we get here, it's because there was no policy to reject empty subjects.
		if ($oEmail->sSubject == '')
		{
			$sDefaultSubject = ($this->Get('policy_no_subject_default_value') == '') ? Dict::S('MailInbox:NoSubject') : $this->Get('policy_no_subject_default_value');
			$this->Trace("The incoming email has no subject, the ticket title will be set to: {$sDefaultSubject}");
			$oTicket->Set('title', $sDefaultSubject);
		}
		else
		{
			$oTicketTitleAttDef = MetaModel::GetAttributeDef(get_class($oTicket), 'title');
			$iTitleMaxSize = $oTicketTitleAttDef->GetMaxSize();
			 
			// Remove certain patterns from the title?
			$sSubject = $oEmail->sSubject;
			if( $this->Get('policy_remove_pattern_patterns') != '' && $this->Get('policy_remove_pattern_behavior') == 'delete' ) {
			
				$aRemoveTitlePatterns = explode('/\\r\\n|\\r|\\n/', $this->Get('policy_remove_pattern_patterns'));
				
				foreach( $aRemoveTitlePatterns as $sRemoveTitlePattern ) {
					$oPregMatch = @preg_match($sRemoveTitlePattern, $sSubject);
					
					if( $oPregMatch === false) {
						$this->Trace("... Invalid pattern: {$sRemoveTitlePattern}");
						break;
					}
					elseif( $oPregMatch != false ) {
						$sSubject = preg_replace($sRemoveTitlePattern, '', $sSubject);
					}
					
				}
			}
			
			$oTicket->Set('title', substr( $sSubject , 0, $iTitleMaxSize));
		}
		
		$aIgnoredAttachments = array();
		
		
		// Get list of forbidden file types 
		if( $this->Get('policy_forbidden_attachments_mimetypes') != '' ) {
			$aForbiddenMimeTypes = preg_split('/\\r\\n|\\r|\\n/', $this->Get('policy_forbidden_attachments_mimetypes') );
			
			// Forbidden attachments? 
			foreach($oEmail->aAttachments as $index => $aAttachment)
			{ 
				if ( in_array( $aAttachment['mimeType'], $aForbiddenMimeTypes ) )
				{
					$this->Trace("... Attachment Content-Id ". $aAttachment['content-id'] . " - Mime Type: {$aAttachment['mimeType']} = forbidden.");
					// In the Combodo version, you often see $aIgnoredAttachments ; however it's barely used. 
					// Instead, we remove it ourselves.
					unset( $oEmail->aAttachments[ $index ] );
				}
				else {
					$this->Trace("... Attachment Content-Id ". $aAttachment['content-id'] . " - Mime Type: {$aAttachment['mimeType']} = allowed.");
				}
			}
			
		}
		
		// Insert the remaining attachments so that we know their ID and can reference them in the message's body
		$aAddedAttachments = $this->AddAttachments($oTicket, $oEmail, true, $aIgnoredAttachments);  // Cannot insert them for real since the Ticket is not saved yet (we don't know its ID)
																									// we'll have to call UpdateAttachments once the ticket is properly saved
																									
		// Seems to be for backward compatibility / plain text.																							
		$oTicketDescriptionAttDef = MetaModel::GetAttributeDef(get_class($oTicket), 'description');
		$bForPlainText = true; // Target format is plain text (by default)
		if ($oTicketDescriptionAttDef instanceof AttributeHTML)
		{
			// Target format is HTML
			$bForPlainText = false;
		}
		else if ($oTicketDescriptionAttDef instanceof AttributeText)
		{
			$aParams = $oTicketDescriptionAttDef->GetParams();
			if (array_key_exists('format', $aParams) && ($aParams['format'] == 'html'))
			{
				// Target format is HTML
				$bForPlainText = false;
			}
		}
		$this->Trace("Target format for 'description': ".($bForPlainText ? 'text/plain' : 'text/html'));
		$this->Trace("Email body format: ".$oEmail->sBodyFormat);
		
		$sTicketDescription = $this->BuildDescription($oEmail, $aAddedAttachments, $aIgnoredAttachments, $bForPlainText);

		$iDescriptionMaxSize = $oTicketDescriptionAttDef->GetMaxSize();
		if (strlen($sTicketDescription) > $iDescriptionMaxSize)
		{
			$oEmail->aAttachments[] = array('content' => $sTicketDescription, 'filename' => ($bForPlainText ? 'original message.txt' : 'original message.html'), 'mimeType' => ($bForPlainText ? 'text/plain' : 'text/html'));
		}
		
		$oTicket->Set('description', $this->FitTextIn($sTicketDescription, $iDescriptionMaxSize - 1000)); // Keep some room just in case...
		
		// Default values
		$sDefaultValues = $this->Get('ticket_default_values');
		$aDefaults = explode("\n", $sDefaultValues);
		$aDefaultValues = array();
		foreach($aDefaults as $sLine)
		{
			if (preg_match('/^([^:]+):(.*)$/', $sLine, $aMatches))
			{
				$sAttCode = trim($aMatches[1]);
				$sValue = trim($aMatches[2]);
				$aDefaultValues[$sAttCode] = $sValue;
			}
		}
		$this->InitObjectFromDefaultValues($oTicket, $aDefaultValues);
		
		// We will only call this if additional contacts are accepted by our policy 
		if ( in_array($this->Get('policy_other_recipients_behavior'), ['add_existing_contacts', 'add_all_contacts'] ) == true )
		{
			$this->AddAdditionalContacts($oTicket, $oEmail);
		}
		
		$this->BeforeInsertTicket($oTicket, $oEmail, $oCaller);
		$oTicket->DBInsert();
		$this->Trace("Ticket ".$oTicket->GetName()." created.");
		$this->AfterInsertTicket($oTicket, $oEmail, $oCaller, $aAddedAttachments);
						
		return $oTicket;
	}

	/**
	 * Build the 'description' of the ticket when creating a new ticket
	 * @param EmailMessage $oEmail The incoming Email
	 * @param bool $bForPlainText True if the desired output format is plain text, false if HTML
	 * @return string
	 */
	protected function BuildDescription(EmailMessage $oEmail, $aAddedAttachments, $aIgnoredAttachments, $bForPlainText)
	{
		$sTicketDescription = '';
		if ($oEmail->sBodyFormat == 'text/html')
		{
			// Original message is in HTML
			$this->Trace("Managing inline images...");
			$sTicketDescription = $this->ManageInlineImages($oEmail->sBodyText, $aAddedAttachments, $aIgnoredAttachments, $bForPlainText);
			if ($bForPlainText)
			{
				$this->Trace("Converting HTML to text using utils::HtmlToText...");
				$sTicketDescription = utils::HtmlToText($oEmail->sBodyText);
			}
		}
		else
		{
			// Original message is in plain text
			$sTicketDescription = utils::TextToHtml($oEmail->sBodyText);
			if (!$bForPlainText)
			{
				$this->Trace("Converting text to HTML using utils::TextToHtml...");
				$sTicketDescription = utils::TextToHtml($oEmail->sBodyText);
			}
		}

		if (empty($sTicketDescription))
		{
			$sTicketDescription = 'No description provided.';
		}
		
		return $sTicketDescription;
	}

	/**
	 * Add the contacts in To: or CC: as additional contacts to the ticket (if they exist in the DB)
	 * @param Ticket $oTicket
	 * @param EmailMessage $oEmail
	 */
	protected function AddAdditionalContacts(Ticket $oTicket, EmailMessage $oEmail)
	{
		$oContactsSet = $oTicket->Get('contacts_list');
		$aExistingContacts = array();
		while($oLnk = $oContactsSet->Fetch())
		{
			$aExistingContacts[$oLnk->Get('contact_id')] = true;
		}
		$aAdditionalContacts = array_merge($oEmail->aTos, $oEmail->aCCs); // Take both the To: and CC:, no actual merge since the keys of the arrays are numeric (i.e. 0, 1, 2...)
		foreach($aAdditionalContacts as $aInfo)
		{
			$sCallerEmail = $oTicket->Get('caller_id->email');
			// Exclude the caller from the additional contacts
			if ($aInfo['email'] != $sCallerEmail)
			{
				$oContact = $this->FindAdditionalContact($aInfo['email']);
				if (($oContact != null) && !array_key_exists($oContact->GetKey(), $aExistingContacts))
				{
					$oLnk = new lnkContactToTicket();
					$oLnk->Set('contact_id', $oContact->GetKey());
					$oContactsSet->AddObject($oLnk);
				}
			}
			else
			{
				$this->Trace("Skipping '{$sCallerEmail}' from the email address in To/CC since it is the same as the caller's email.");
			}
		}
		$oTicket->Set('contacts_list', $oContactsSet);
	}

	/**
	 * Search if the CC email is an existing contact in iTop, if so return it, otherwise ignore it
	 * @param $sEmail string The email address to search
	 * @return Contact | null
	 */
	protected function FindAdditionalContact($sEmail)
	{
		$oContact = null;
		$sContactQuery = 'SELECT Person WHERE email = :email';
		$oSet = new DBObjectSet(DBObjectSearch::FromOQL($sContactQuery), array(), array('email' => $sEmail));
		switch($oSet->Count())
		{
			case 1:
				// Ok, the caller was found in iTop
				$oContact = $oSet->Fetch();
				$this->Trace("Found Contact: ID {$oContact->GetKey()} ({$oContact->GetName()}) from the email address in To/CC '{$sEmail}'.");
				break;
			
			case 0:
				$this->Trace("No contact found with the email address in To/CC '{$sEmail}', email address ignored.");
				break;
			
			default:
				// Multiple contacts with the same email address!
				$this->Trace("Found {$oSet->Count()} contacts with the same email address in To/CC '{$sEmail}', the first one will be used.");
				$oCaller = $oSet->Fetch();
		}
		return $oContact;
	}

	/**
	 * Handler called just before inserting the ticket into the database
	 * Overload this method to adjust the values of the ticket at your will
	 * @param Ticket $oTicket
	 * @param EmailMessage $oEmail
	 * @param Contact $oCaller
	 */
	protected function BeforeInsertTicket(Ticket $oTicket, EmailMessage $oEmail, Contact $oCaller)
	{
		// Default implementation: do nothing
	}

	/**
	 * Finalize the processing after the insertion of the ticket in the database
	 * @param Ticket $oTicket The ticket being written
	 * @param EmailMessage $oEmail The source email
	 * @param Contact $oCaller The caller for this ticket, as passed to CreateTicket
	 * @param array $aAddedAttachments The array of attachments added to the ticket
	 */
	protected function AfterInsertTicket(Ticket $oTicket, EmailMessage $oEmail, Contact $oCaller, $aAddedAttachments)
	{
		// Process attachments
		$this->UpdateAttachments($aAddedAttachments, $oTicket); // Now update the attachments since we know the ID of the ticket
		
		// Shall we delete the source email immediately?
		if ($this->Get('email_storage') == 'delete')
		{
			// Remove the processed message from the mailbox
			$this->Trace("Ticket created, deleting the source eMail '{$oEmail->sSubject}'");
			$this->SetNextAction(EmailProcessor::DELETE_MESSAGE);		
		}
		else
		{
			// Keep the message in the mailbox
			$this->SetNextAction(EmailProcessor::NO_ACTION);		
		}		
	}

	/**
	 * Actual update of a ticket from the incoming email. Overload this method
	 * to implement your own behavior, if needed
	 * @param Ticket $oTicket The ticket to update
	 * @param EmailMessage $oEmail The decoded incoming email
	 * @param Contact $oCaller The contact corresponding to the "From" email address
	 * @return void
	 */
	public function UpdateTicketFromEmail(Ticket $oTicket, EmailMessage $oEmail, Contact $oCaller)
	{
		// In case of error (exception...) set the behavior
		if ($this->Get('error_behavior') == 'delete')
		{
			$this->SetNextAction(EmailProcessor::DELETE_MESSAGE); // Remove the message from the mailbox
		}
		else
		{
			$this->SetNextAction(EmailProcessor::MARK_MESSAGE_AS_ERROR); // Keep the message in the mailbox, but marked as error
		}		
		
		// Check that the ticket is of the expected class
		if (!is_a($oTicket, $this->Get('target_class')))
		{
			$this->Trace("iTop Simple Email Synchro: Error: the incoming email refers to the ticket ".$oTicket->GetName()." of class {get_class($oTicket)}, but this mailbox is configured to process only tickets of class {$this->Get('target_class')}");
			$this->SetNextAction(EmailProcessor::MARK_MESSAGE_AS_ERROR); // Keep the message in the mailbox, but marked as error
			return;
		}
		
		// Try to extract what's new from the message's body
		$this->Trace("iTop Simple Email Synchro: Updating the iTop ticket {$oTicket->GetName()} from eMail '{$oEmail->sSubject}'");

		// Not policy compliant? Then stop processing. 
		// Careful: Combodo's version implemented an IsUndesired-method in later versions (v3.0.11).
		// Our method needs an additional parameter ( $oTicket ) to handle some policies.
		$oPolicy = $this->IsUndesired($oEmail, $oTicket);
		
		// Not policy compliant? Then stop processing. 
		if( $oPolicy->bUndesired ) {
			$this->Trace(". Email (update) does not comply with at least one policy ({$oPolicy->sPolicyId}) - so undesired.");
			$this->HandlePolicyViolation($oEmail, $oPolicy->sPolicyId, $oEmail->oRawEmail);
			return null;
		}
		else {
			$this->Trace(". Email (update) complies with our policies.");
		}
		 
		$oCaller = $oPolicy->oCaller;
		
		// Everything compliant, but we might need to perform actions.
		
		// Process attachments
		$aIgnoredAttachments = array();
		$aAddedAttachments = $this->AddAttachments($oTicket, $oEmail, true, $aIgnoredAttachments);
		
		$sCaseLogEntry = $this->BuildCaseLogEntry($oEmail, $aAddedAttachments, $aIgnoredAttachments);
		
		$this->Trace($oEmail->sTrace);
		
		// Write the log on behalf of the caller
		$sCallerName = $oEmail->sCallerName;
		if (empty($sCallerName))
		{
			$sCallerName = $oEmail->sCallerEmail;
		}
					
		// Determine which field to update
		$sAttCode = 'public_log';
		$aAttCodes = MetaModel::GetModuleSetting('jb-itop-standard-email-synchro', 'ticket_log', array('UserRequest' => 'public_log', 'Incident' => 'public_log'));
		if (array_key_exists(get_class($oTicket), $aAttCodes))
		{
			$sAttCode = $aAttCodes[get_class($oTicket)];
		}
		
		$oCaseLog = $oTicket->Get($sAttCode);
		$oAttributeValue = new \jb_mail_to_ticket_automation\ormCustomCaseLog();
		
		// GetForJSON() actually returns an array of each entry
		foreach($oCaseLog->GetAsArray() as $aEntry) {
			
			// CustomCaseLog's AddLogEntry remains flexible; keeps original user information and datetime
			$oAttributeValue->AddLogEntry( $aEntry['message_html'], $aEntry['user_login'], $aEntry['user_id'], $aEntry['date'] );
			
		}
		
		$oLog->AddLogEntry($sCaseLogEntry, $sCallerName, null, '');
		
		// Sort chronologically. NOT ascending (true), but descending (false)!
		$oAttributeValue = $oAttributeValue->ToSortedCaseLog(false);
		
		$oTicket->Set($sAttCode, $oAttributeValue);
		
		if ( in_array( $this->Get('policy_other_recipients_behavior'), ['add_all_contacts', 'add_existing_contacts'] ) == true )
		{
			$this->AddAdditionalContacts($oTicket, $oEmail);
		}
		$this->BeforeUpdateTicket($oTicket, $oEmail, $oCaller);
		$oTicket->DBUpdate();			
		$this->Trace("Ticket {$oTicket->GetName()} updated.");
		$this->AfterUpdateTicket($oTicket, $oEmail, $oCaller);
				
		return $oTicket;		
	}

	/**
	 * Build the text/html to be inserted in the case log when the ticket is updated
	 * Starting with iTop 2.3.0, the format is always HTML
	 * @param EmailMessage $oEmail
	 * @return string The HTML text to be inserted in the case log
	 */
	protected function BuildCaseLogEntry(EmailMessage $oEmail, $aAddedAttachments, $aIgnoredAttachments)
	{
		$sCaseLogEntry = '';
		$this->Trace("Email body format: ".$oEmail->sBodyFormat);
		if ($oEmail->sBodyFormat == 'text/html')
		{
			$this->Trace("Extracting the new part using GetNewPartHTML...");
			$sCaseLogEntry = $oEmail->GetNewPartHTML($oEmail->sBodyText);
			if (strip_tags($sCaseLogEntry) == '')
			{
				// No new part (only blank tags)... we'd better use the whole text of the message
				$sCaseLogEntry = $oEmail->sBodyText;
			}
			$this->Trace("Managing inline images...");
			$sCaseLogEntry = $this->ManageInlineImages($sCaseLogEntry, $aAddedAttachments, $aIgnoredAttachments, false /* $bForPlainText */);
		}
		else
		{
			$this->Trace("Extracting the new part using GetNewPart...");
			$sCaseLogEntry = $oEmail->GetNewPart($oEmail->sBodyText, $oEmail->sBodyFormat); // GetNewPart always returns a plain text version of the message
			$sCaseLogEntry = utils::TextToHtml($sCaseLogEntry);
		}
		return $sCaseLogEntry;
	}

	/**
	 * Handler called before updating a ticket in the database
	 * Overload this method to alter the ticket at your will
	 * @param Ticket $oTicket
	 * @param EmailMessage $oEmail
	 * @param Contact $oCaller
	 */
	protected function BeforeUpdateTicket(Ticket $oTicket, EmailMessage $oEmail, Contact $oCaller)
	{
		// Default implementation: do nothing
	}

	/**
	 * Read the configuration in the 'stimuli' field (format: <state_code>:<stimulus_code>, one per line)
	 * and apply the corresponding stimulus according to the current state of the ticket
	 * @param ticket $oTicket
	 */
	protected function ApplyConfiguredStimulus(ticket $oTicket)
	{
	
		$sConf = $this->Get('stimuli');
		
		// In Combodo's version, this resulted in a warning?
		// We will reopen ticket elsewhere if needed.
		if( trim($sConf) == '' ) {
			return;
		}
	
		$aConf = explode("\n", $sConf);
		$aStateToStimulus = array();
		foreach($aConf as $sLine)
		{
			if (preg_match('/^([^:]+):(.*)$/', $sLine, $aMatches))
			{
				$sState = trim($aMatches[1]);
				$sStimulus = trim($aMatches[2]);
				$aStateToStimulus[$sState] = $sStimulus;
			}
			elseif (!empty($sLine))
			{
				$this->Trace("Invalid line in the 'stimuli' configuration: '{$sLine}'. The expected format for each line is <state_code>:<stimulus_code>");
			}
		}
		if (array_key_exists($oTicket->GetState(), $aStateToStimulus))
		{
			$sStimulusCode = $aStateToStimulus[$oTicket->GetState()];
			$this->Trace("About to apply the stimulus: ".$sStimulusCode." for the ticket in state: ".$oTicket->GetState());
			
			// Check that applying the stimulus will not break the data integrity constaints (mandatory, must change)
			$aTransitions = $oTicket->EnumTransitions();
			$bCanApplyStimulus = true;
			if (!isset($aTransitions[$sStimulusCode]))
			{
				$bCanApplyStimulus = false;
				$this->Trace("The Stimulus {$sStimulusCode} for ".get_class($oTicket)." in state {$oTicket->GetState()} has no effect (no transition). Ignored.");
			}
			else
			{
				
				$aTransitionDef = $aTransitions[$sStimulusCode];
				$sTargetState = $aTransitionDef['target_state'];
				$aTargetStates = MetaModel::EnumStates(get_class($oTicket));
				$aTargetStateDef = $aTargetStates[$sTargetState];
				$aExpectedAttributes = $aTargetStateDef['attribute_list'];
				foreach($aExpectedAttributes as $sAttCode => $iExpectCode)
				{
					$oAttDef = MetaModel::GetAttributeDef(get_class($oTicket), $sAttCode);
					if (($iExpectCode & OPT_ATT_MANDATORY) && ($oAttDef->IsNull($oTicket->Get($sAttCode))))
					{
						// Check if there is just one possible value, in which case, use it				
						$aArgs = array('this' => $oTicket);
						// If the field is mandatory, set it to the only possible value
						if ($oAttDef->IsExternalKey())
						{
							$oAllowedValues = MetaModel::GetAllowedValuesAsObjectSet(get_class($oTicket), $sAttCode, $aArgs);
							if ($oAllowedValues->Count() == 1)
							{
								$oRemoteObj = $oAllowedValues->Fetch();
								$oTicket->Set($sAttCode, $oRemoteObj->GetKey());
								$this->Trace("Setting the mandatory External Key {$sAttCode} to the only allowed value: {$oRemoteObj->GetKey()}");
							}
							else
							{
								$this->Trace("Cannot apply the stimulus since the attribute {$sAttCode} is mandatory in the target state {$sTargetState} and is neither currently set nor has just one allowed value.");
								$bCanApplyStimulus = false;
							}
						}
						else
						{
							$aAllowedValues = MetaModel::GetAllowedValues_att(get_class($oTicket), $sAttCode, $aArgs);
							if (count($aAllowedValues) == 1)
							{
								$aValues = array_keys($aAllowedValues);
								$oTicket->Set($sAttCode, $aValues[0]);
								$this->Trace("Setting the mandatory attribute {$sAttCode} to the only allowed value: ".(string)$aValues[0]);
							}
							else
							{
								$this->Trace("Cannot apply the stimulus since the attribute {$sAttCode} is mandatory in the target state {$sTargetState} and is neither currently set nor has just one allowed value.");
								$bCanApplyStimulus = false;
							}
						}
					}
					if ($iExpectCode & OPT_ATT_MUSTCHANGE)
					{
						$this->Trace("Cannot apply the stimulus since the value of the attribute {$sAttCode} must be modified (manually) during the transition to the target state {$sTargetState}.");
						$bCanApplyStimulus = false;
					}
				}
			}
			
			if ($bCanApplyStimulus)
			{
				try
				{
					$this->Trace("Actually applying the stimulus: {$sStimulusCode} for the ticket in state: {$oTicket->GetState()}");
					$oTicket->ApplyStimulus($sStimulusCode);
				}
				catch(Exception $e)
				{
					$this->Trace("ApplyStimulus failed: {$e->getMessage()}");
				}
			}
			else
			{
				$this->Trace("ApplyStimulus ignored.");
			}
		}
	}

	/**
	 * Finalize the processing after the update of the ticket in the database
	 * @param Ticket $oTicket The ticket being written
	 * @param EmailMessage $oEmail The source email
	 * @param Contact $oCaller The caller for this ticket, as passed to UpdateTicket
	 */
	protected function AfterUpdateTicket(Ticket $oTicket, EmailMessage $oEmail, Contact $oCaller)
	{
		// If there are any TriggerOnMailUpdate defined, let's activate them
		$aClasses = MetaModel::EnumParentClasses(get_class($oTicket), ENUM_PARENT_CLASSES_ALL);
		$sClassList = implode(", ", CMDBSource::Quote($aClasses));
		$oSet = new DBObjectSet(DBObjectSearch::FromOQL("SELECT TriggerOnMailUpdate AS t WHERE t.target_class IN ($sClassList)"));
		while ($oTrigger = $oSet->Fetch())
		{
			$oTrigger->DoActivate($oTicket->ToArgs('this'));
		}

		// Apply a stimulus if needed, will write the ticket to the database, may launch triggers, etc...
		$this->ApplyConfiguredStimulus($oTicket);
		
		// Shall we keep the email or delete it immediately?
		if ($this->Get('email_storage') == 'delete')
		{
			// Remove the processed message from the mailbox
			$this->Trace("Ticket updated, deleting the source eMail '{$oEmail->sSubject}'");
			$this->SetNextAction(EmailProcessor::DELETE_MESSAGE);		
		}
		else
		{
			// Keep the message in the mailbox
			$this->SetNextAction(EmailProcessor::NO_ACTION);		
		}
	}


	protected function ManageInlineImages($sBodyText, $aAddedAttachments, $aIgnoredAttachments, $bForPlainText = true)
	{
		// Search for inline images: i.e. <img tags containing an src="cid:...." or without double quotes e.g. src=cid:xyzxyzx
		// Note: (?: ... ) is used for grouping the alternative without creating a "matching group"
		if (preg_match_all('/<img[^>]+src=(?:"cid:([^"]+)"|cid:([^ >]+))[^>]*>/i', $sBodyText, $aMatches, PREG_OFFSET_CAPTURE))
		{
			$aInlineImages = array();
			foreach ($aMatches[0] as $idx => $aInfo)
			{
				$aInlineImages[$idx] = array(
					'position' => $aInfo[1]
				);
			}
			foreach ($aMatches[1] as $idx => $aInfo)
			{
				$sCID = $aInfo[0];
				if (!array_key_exists($sCID, $aAddedAttachments) && !array_key_exists($sCID, $aIgnoredAttachments))
				{
					$this->Trace("Info: inline image: {$sCID} not found as an attachment. Ignored.");
				}
				else if (array_key_exists($sCID, $aAddedAttachments))
				{
					$aInlineImages[$idx]['cid'] = $sCID;
					$this->Trace("Inline image cid:$sCID stored as ".get_class($aAddedAttachments[$sCID])."::".$aAddedAttachments[$sCID]->GetKey());
				}
			}
			if (!defined('ATTACHMENT_DOWNLOAD_URL'))
			{
				define('ATTACHMENT_DOWNLOAD_URL', 'pages/ajax.render.php?operation=download_document&class=Attachment&field=contents&id=');
			}
			if ($bForPlainText)
			{
				// The target form is text/plain, so the HTML tags will be stripped
				// Insert the URLs to the attachments, just before the <img tag so that the hyperlink remains (as plain text) at the right position
				// when the HTML tags will be stripped
				// Start from the end of the text to preserve the positions of the <img tags AFTER the insertion
				$sWholeText = $sBodyText;
				$idx = count($aInlineImages);
				while ($idx > 0)
				{
					$idx --;
					if (array_key_exists('cid', $aInlineImages[$idx]))
					{
						$sBefore = substr($sWholeText, 0, $aInlineImages[$idx]['position']);
						$sAfter = substr($sWholeText, $aInlineImages[$idx]['position']);
						$oAttachment = $aAddedAttachments[$aInlineImages[$idx]['cid']];
						$sUrl = utils::GetAbsoluteUrlAppRoot().ATTACHMENT_DOWNLOAD_URL.$oAttachment->GetKey();
						$sWholeText = $sBefore.' '.$sUrl.' '. $sAfter;
					}
				}
			}
			else
			{
				// The target format is text/html, keep the formatting, but just change the URLs
				$aSearches = array();
				$aReplacements = array();
				foreach($aAddedAttachments as $sCID => $oAttachment)
				{
					$aSearches[] = 'src="cid:'.$sCID.'"';
					if (class_exists('InlineImage') && ($oAttachment instanceof InlineImage))
					{
						// Inline images have a special download URL requiring the 'secret' token
						$aReplacements[] = 'src="'.utils::GetAbsoluteUrlAppRoot().INLINEIMAGE_DOWNLOAD_URL.$oAttachment->GetKey().'&s='.$oAttachment->Get('secret').'"';
					}
					else
					{
						$aReplacements[] = 'src="'.utils::GetAbsoluteUrlAppRoot().ATTACHMENT_DOWNLOAD_URL.$oAttachment->GetKey().'"';
					}
					$aSearches[] = 'src=cid:'.$sCID; // Same without quotes
					if (class_exists('InlineImage') && ($oAttachment instanceof InlineImage))
					{
						// Inline images have a special download URL requiring the 'secret' token
						$aReplacements[] = 'src="'.utils::GetAbsoluteUrlAppRoot().INLINEIMAGE_DOWNLOAD_URL.$oAttachment->GetKey().'&s='.$oAttachment->Get('secret').'" '; // Beware we need to add a space at the end
					}
					else
					{
						$aReplacements[] = 'src="'.utils::GetAbsoluteUrlAppRoot().ATTACHMENT_DOWNLOAD_URL.$oAttachment->GetKey().'" '; // Beware we need to add a space at the end
					}
				}
				$sWholeText = str_replace($aSearches, $aReplacements, $sBodyText);
			}
			$sBodyText = $sWholeText;
		}
		else
		{
			$this->Trace("Inline Images: no inline-image found in the message");
		}
		return $sBodyText;
	}

	/**
	 * Error handler... what to do in case of error ??
	 * @param EmailMessage $oEmail can be null in case of decoding error (like message too big)
	 * @param string $sErrorCode
	 * @return void
	 */
	public function HandleError($oEmail, $sErrorCode, $oRawEmail = null, $sAdditionalErrorMessage = '')
	{
	
		$sTo = $this->Get('notify_errors_to');
		$sFrom = $this->Get('notify_from');
		// The behavior is overriden in case of undesired_message
		if ($this->Get('error_behavior') == 'delete')
		{
			$this->SetNextAction(EmailProcessor::DELETE_MESSAGE); // Remove the message from the mailbox
			$sLastAction = "<p>The eMail was deleted from the mailbox.</p>\n";
		}
		else
		{
			$this->SetNextAction(EmailProcessor::MARK_MESSAGE_AS_ERROR); // Keep the message in the mailbox, but marked as error
			$sLastAction = "<p>The eMail is marked as error and will be ignored in further processing of the mailbox.</p>\n";
		}
		
		switch($sErrorCode)
		{
			case 'decode_failed':
			
				$sSubject = '[iTop] Failed to decode an incoming eMail';
				if ($oRawEmail && ($oRawEmail->GetSize() > EmailBackgroundProcess::$iMaxEmailSize))
				{
					$sBody = "<p>The incoming eMail is bigger (".$oRawEmail->GetSize()." bytes) than the maximum configured size (maximum_email_size = ".EmailBackgroundProcess::$iMaxEmailSize.").</p>\n";
					$this->sLastError = "eMail is bigger (".$oRawEmail->GetSize()." bytes) than the maximum configured size (maximum_email_size = ".EmailBackgroundProcess::$iMaxEmailSize.")";
					
					if ($this->Get('error_behavior') == 'delete')
					{
						if ($this->sBigFilesDir == '')
						{
							$sBody .= "<p>The email was deleted. In the future you can:\n<ul>\n";
							$sBody .= "<li>either increase the 'maximum_email_size' parameter in the iTop configuration file, so that the message gets processed</li>\n";
							$sBody .= "<li>or configure the parameter 'big_files_dir' in the iTop configuration file, so that such emails are kept on the web server for further inspection.</li>\n</ul>";
						}
						else if (!is_writable($this->sBigFilesDir))
						{
							$sBody .= "<p>The email was deleted, since the directory where to save such files on the web server ($this->sBigFilesDir) is NOT writable to iTop.</p>\n";
						}
						else
						{
							$idx = 1;
							$sFileName = 'email_'.(date('Y-m-d')).'_';
							$sExtension = '.eml';
							$hFile = false;
							while(($hFile = fopen($this->sBigFilesDir.'/'.$sFileName.$idx.$sExtension, 'x')) === false)
							{
								$idx++;
							}
							fwrite($hFile, $oRawEmail->GetRawContent());
							fclose($hFile);
							$sBody .= "<p>The message was saved as '{$sFileName}{$idx}{$sExtension}' on the web server, in the directory '{$this->sBigFilesDir}'.</p>\n";
							$sBody .= "<p>In order process such messages, increase the value of the 'maximum_email_size' parameter in the iTop configuration file.</p>\n";
						}
					}
					else
					{
						$sBody .= $sLastAction;
					}
									
					$oRawEmail = null; // Do not attach the original message to the mail sent to the admin since it's already big, send the message now
					$this->Trace($sSubject."\n\n".$sBody);
					// Send the email now...
					if(($sTo != '') && ($sFrom != ''))
					{
						$oEmailToSend = new Email();
						$oEmailToSend->SetRecipientTO($sTo);
						$oEmailToSend->SetSubject($sSubject);
						$oEmailToSend->SetBody($sBody, 'text/html');	
						$oEmailToSend->SetRecipientFrom($sFrom);
						$oEmailToSend->Send($aIssues, true /* bForceSynchronous */, null /* $oLog */);
					}
				}
				else
				{
					$sBody = "<p>The following eMail (see attachment) was not decoded properly and therefore was not processed at all.</p>\n";
					$sBody .= $sLastAction;
				}
			break;
			
			
			case 'failed_to_create_contact':
			
				$sSubject = '[iTop] Failed to create a contact for the incoming eMail - '.$oEmail->sSubject;
				$sBody = "<p>The following email (see attachment) comes from an unknown caller (".$oEmail->sCallerEmail.").<br/>\n";
				$sBody .= "The configuration of the Mail Inbox ".$this->GetName()." instructs to create a new contact based on some default values, but this creation was not successful.<br/>\n";
				$sBody .= "Check the contact's default values configured in the Mail Inbox.</p>\n";
				$sBody .= $sLastAction;
				$this->sLastError = "Failed to create a contact from the incoming eMail. Caller = ".$oEmail->sCallerEmail;
				break;
			
			case 'rejected_attachments':
			
				$sSubject = '[iTop] Failed to process attachment(s) for the incoming eMail - '.$oEmail->sSubject;
				$sBody = "<p>Some attachments to the eMail were not processed because they are too big:</p>\n";
				$sBody .= "<pre>".$sAdditionalErrorMessage."</pre>\n";
				$sBody .= $sLastAction;
				
				$oRawEmail = null; // No original message in attachment
				$this->Trace($sSubject."\n\n".$sBody);
				// Send the email now...
				if(($sTo != '') && ($sFrom != ''))
				{
					$oEmailToSend = new Email();
					$oEmailToSend->SetRecipientTO($sTo);
					$oEmailToSend->SetSubject($sSubject);
					$oEmailToSend->SetBody($sBody, 'text/html');	
					$oEmailToSend->SetRecipientFrom($sFrom);
					$oEmailToSend->Send($aIssues, true /* bForceSynchronous */, null /* $oLog */);
				}
				break;
			 
			case 'undesired_message':
			
				$sSubject = '[iTop] Undesired message - '.$oEmail->sSubject;
				$sBody = "<p>The attached message was rejected because it is considered as undesired, based on the 'undesired_subject_patterns' specified in the iTop configuration file.</p>\n";
				$sBody .= $sLastAction;
				
				// Send the email now...
				if(($sTo != '') && ($sFrom != ''))
				{
					$oEmailToSend = new Email();
					$oEmailToSend->SetRecipientTO($sTo);
					$oEmailToSend->SetSubject($sSubject);
					$oEmailToSend->SetBody($sBody, 'text/html');	
					$oEmailToSend->SetRecipientFrom($sFrom);
					$oEmailToSend->Send($aIssues, true /* bForceSynchronous */, null /* $oLog */);
				}
				break;
				
			case 'undesired_message':
				if (MetaModel::GetModuleSetting('jb-email-synchro', 'undesired-purge-delay', 7) == 0)
				{
					$this->SetNextAction(EmailProcessor::DELETE_MESSAGE); // immediate delete when delay is 0
				}
				else
				{
					$this->SetNextAction(EmailProcessor::MARK_MESSAGE_AS_UNDESIRED); // Keep the message in the mailbox, but marked as undesired
				}
				$this->sLastError = 'Undesired email';
				$oRawEmail = null; // No feedback on undesired emails
				break;
				
			
			default:
				$sSubject = '[iTop] handle error';
				$sBody = '<p>Unexpected error: '.$sErrorCode."</p>\n";
				$sBody .= $sLastAction;
				$this->sLastError = 'Unexpected error: '.$sErrorCode;
		}
		$sBody .= "<p>&nbsp;</p><p>Mail Inbox Configuration: ".$this->GetHyperlink()."</p>\n";
		
		if(($sTo == '') || ($sFrom == ''))
		{
			$this->Trace("HandleError($sErrorCode): No forward configured for forwarding the email...(To: '$sTo', From: '$sFrom'), skipping.");
		}
		else if($oRawEmail)
		{
			$this->Trace($sSubject."\n\n".$sBody);
			$oRawEmail->SendAsAttachment($sTo, $sFrom, $sSubject, $sBody);
		}
	}

	/**
	 * Policy violation handler... what to do in case of Policy violation ?
	 * @param EmailMessage $oEmail can be null in case of decoding error (like message too big)
	 * @param string $sPolicyViolation
	 * @return void
	 */
	public function HandlePolicyViolation($oEmail, $sPolicyViolation, $oRawEmail = null, $sAdditionalErrorMessage = '')
	{
	
		// Rather than informing the admin, we need to inform the sender who doesn't follow guidelines.		
		// You can try user education, but sometimes you need to rely on enforcing policies rather than just giving in.
		$sTo = $oEmail->sCallerEmail;
		$sFrom = $this->Get('notify_from'); 
	
		// Policy violations have a typical way of handling.
		// The behavior is usually one of the following:
		// - bounce and delete the message
		// - delete the message
		// - mark as undesired (stays in the mailbox for a few days)
		// - fallback (usually ignoring or using default values, shouldn't end up here.)  
		
		$this->Trace("HandlePolicyViolation($sPolicyViolation): The behavior for {$sPolicyViolation} is {$this->Get( $sPolicyViolation.'_behavior')}");
		
		switch( $this->Get( $sPolicyViolation.'_behavior' ) ){
		
			// Generic cases
			case 'bounce_delete':
			case 'bounce_mark_as_undesired':
				
				// $oRawEmail->GetSize()." bytes) than the maximum configured size (maximum_email_size = ".EmailBackgroundProcess::$iMaxEmailSize
								
				$sSubject = $this->Get( $sPolicyViolation.'_subject' );
				$sBody = $this->Get( $sPolicyViolation.'_notification'); 
				
				// Allow some customization in the bounce message
				$sSubject = $this->ReplaceMailVariables($sSubject, $oEmail);
				$sBody = $this->ReplaceMailVariables($sBody, $oEmail);
				
				// Return to sender.
				if($sTo == ''){ 
					$this->Trace("HandlePolicyViolation($sPolicyViolation): No 'to' defined, skipping.");
				}
				elseif($sFrom == ''){ 
					$this->Trace("HandlePolicyViolation($sPolicyViolation): No 'from' defined, skipping.");
				}
				else if($oRawEmail){
					$this->Trace("Raw Email: ".$sSubject."\n\n".strip_tags($sBody));
					$oRawEmail->SendAsAttachment($sTo, $sFrom, $sSubject, $sBody);
				}
				
				switch( $this->Get( $sPolicyViolation.'_behavior' ) ) {
					case 'bounce_delete': 
						$this->Trace("Set next action for EmailProcessor to DELETE_MESSAGE");
						$this->SetNextAction(EmailProcessor::DELETE_MESSAGE); // Remove the message from the mailbox
						$sLastAction = "<p>The eMail was deleted from the mailbox after being bounced to sender (".$sTo.").</p>\n";			
						break;
						
					case 'bounce_mark_as_undesired':
						$this->Trace("Set next action for EmailProcessor to MARK_MESSAGE_AS_UNDESIRED");
						$this->SetNextAction(EmailProcessor::MARK_MESSAGE_AS_UNDESIRED); // Keep the message temporarily in the mailbox, but marked as undesired
						$sLastAction = "<p>The eMail is marked as undesired and will be deleted after the specified interval.</p>\n";
						break; 
						
					default: 
						// Unexpected
					
				}
				break;
				
			case 'delete': 
				$this->Trace("Set next action for EmailProcessor to DELETE_MESSAGE");
				$this->SetNextAction(EmailProcessor::DELETE_MESSAGE); // Remove the message from the mailbox
				$sLastAction = "<p>The eMail was deleted from the mailbox.</p>\n";			
				break;
				
			// Mark as error should be irrelevant now. Keeping it just in case.
			case 'mark_as_error': 
				$this->Trace("Set next action for EmailProcessor to MARK_MESSAGE_AS_ERROR");
				$this->SetNextAction(EmailProcessor::MARK_MESSAGE_AS_ERROR); // Keep the message in the mailbox, but marked as error
				$sLastAction = "<p>The eMail is marked as error and will be ignored in further processing of the mailbox.</p>\n";
				break;
				 
			case 'mark_as_undesired': 
				$this->Trace("Set next action for EmailProcessor to MARK_MESSAGE_AS_UNDESIRED");
				$this->SetNextAction(EmailProcessor::MARK_MESSAGE_AS_UNDESIRED); // Keep the message temporarily in the mailbox, but marked as undesired
				$sLastAction = "<p>The eMail is marked as undesired and will be deleted after the specified interval.</p>\n";
				break;
				
			// One fallback
			// Any specific fallback (policy_other_recipients_behavior)
			case 'fallback': 
			default: 
			
				$this->Trace("HandlePolicyViolation ending up in a fallback/default for {$sPolicyViolation}");
				 
				
		}
		 
		
		 
	}

	/**
	 * Check all policies to see if the email is considered as "undesired"
	 * @param EmailMessage $oEmail The message to check
	 * @param $oTicket The ticket being written (Ticket or null)
	 * @return array ( boolean 'compliant', Ticket 'ticket', string 'Caller' )
	 */
	protected function IsUndesired(EmailMessage $oEmail, /* Ticket or null */ $oTicket)
	{
		

		// --- Policies ---
		// Start to check if mails are compliant with policies.  
		// The generic HandlePolicyViolation will take care of default actions (bounce, delete, mark as undesired ...)
		// Fallbacks are handled in specific functions. 
		// For example 'no subject' is allowed, it will be handled later on in CreateTicketFromEmail 
		
		$oCaller = null; 
		
		// ### Policy: Forbidden Attachments.
		$this->Trace(".. Policy: forbidden attachments. Behavior: {$this->Get('policy_forbidden_attachments_behavior')}");
		
			if( $this->Get('policy_forbidden_attachments_behavior') == 'fallback' ) {
				// Will be processed. Forbidden attachments will be ignored. So fallback does not make sense.
			}
			elseif( $this->Get('policy_forbidden_attachments_mimetypes') != '' ) {
			
				// Get list of forbidden file types 
				$aForbiddenMimeTypes = preg_split('/\\r\\n|\\r|\\n/', $this->Get('policy_forbidden_attachments_mimetypes') );
				
				$this->Trace(".. testing for these forbidden MimeTypes: " . implode(" - ", $aForbiddenMimeTypes) );
								 
				// Forbidden attachments? 
				foreach($oEmail->aAttachments as $aAttachment)
				{ 
					$this->Trace(".. MimeType: {$aAttachment['mimeType']}");
					if ( in_array( $aAttachment['mimeType'], $aForbiddenMimeTypes ) )
					{
						$this->Trace("The message '{$oEmail->sSubject}' is considered as undesired, since it contains an attachment with forbidden MimeType {$aAttachment['mimeType']}");
						return (object)['bUndesired' => true, 'sPolicyId' => 'policy_forbidden_attachments'];
					}
				}
				
			}
			
		// ### Policy: Mail Size
		$this->Trace(".. Policy: mail size");
		
			$oRawEmail = $oEmail->oRawEmail;
			
			if ( $oRawEmail->GetSize() > $this->Get('policy_mail_size_too_big_max_size_MB') * 1024 * 1024 )
			{
				// Mail size too big  
				$this->Trace("The message '{$oEmail->sSubject}' is considered as undesired, since the mail size is too big (mail = '".($oRawEmail->GetSize()/1024/1024)." MB = {$oRawEmail->GetSize()}' bytes, limit = '{$this->Get('policy_mail_size_too_big_max_size_MB')}' MB = '".($this->Get('policy_mail_size_too_big_max_size_MB')*1024*1024)."' bytes ) ");
				return (object)["bUndesired" => true, 'sPolicyId' => 'policy_mail_size_too_big'];
			}
		
		// ### Policy: No subject
		$this->Trace(".. Policy: no subject");	
		
			if( $this->Get('policy_no_subject_behavior') == 'fallback') {
				 // Will use default subject.
			}
			else {
			
				if( $oEmail->sSubject == '' && in_array($this->Get('policy_no_subject_behavior'), ['bounce_delete', 'bounce_mark_as_undesired', 'delete', 'mark_as_undesired']) == true ) {
					$this->Trace("The message '{$oEmail->sSubject}' is considered as undesired, since it has no subject."); 
					return (object)["bUndesired" => true, 'sPolicyId' => 'policy_no_subject'];
				}
		
			}
		
		// ### Policy: No other recipients 
		$this->Trace(".. Policy: no other recipients");
		
			// To implement: check for other recipients in To: or CC: . 
			// Or check if this mailbox (or aliases) are missing in 'To:' (which would happen in BCC)
			
			// Fallback.
			if( in_array( $this->Get('policy_other_recipients_behavior'), ['add_existing_contacts','add_all_contacts','ignore_all_contacts'] ) ){
				// Contacts will be added or ignored.
			} 
			else {
				
				$aAdditionalContacts = array_merge($oEmail->aTos, $oEmail->aCCs); // Take both the To: and CC:, no actual merge since the keys of the arrays are numeric (i.e. 0, 1, 2...)
				$aExcludeContacts = array_merge( [ $oEmail->sCallerEmail ] , preg_split('/\\r\\n|\\r|\\n/' , $this->Get('mail_aliases') )  );

				foreach($aAdditionalContacts as $aInfo)
				{
					// If we find an email address which is from a third party, and it's not:
					// - the original caller 
					// - an alias for this mailbox (can also be seen as: 'personal mail address from IT-staff moved to shared mailbox), 
					// then we're dealing with an undesired message. (another person in To:, CC:)
					if ( !in_array( $aInfo['email'] , $aExcludeContacts ) ) 
					{
						// Found other contacts in To: or CC: 
						$this->Trace("The message '{$oEmail->sSubject}' is considered as undesired, since it contains another recipient (missing alias or unwanted): {$aInfo['email']}");
						return (object)["bUndesired" => true, 'sPolicyId' => 'policy_other_recipients'];
					} 
				}
			}
			
		// ### Policy: No unknown ticket references
			// null object means there was no ticket.
			if( $oTicket === null ) {
			
				// We could be handling a new ticket! 
				// So we would need to check if there was something (header or pattern in subject) which would have lead us to believe there was a ticket. 
			 
				// Why undesired? Because of a pattern in the subject; or an email header? 
				
				// Are there patterns which should be ignored/removed from the title? 
				// To find the reference, let's remove it from our temp variable. 
				// We'll remove it elsewhere if it really needs to be gone.
				// Patterns should be specified 1 per line		
				$sSubject = $oEmail->sSubject;
				if( $this->Get('policy_remove_pattern_patterns') != '' && $this->Get('policy_remove_pattern_behavior') == 'delete' ) {
				
					$aRemoveTitlePatterns = explode('/\\r\\n|\\r|\\n/', $this->Get('policy_remove_pattern_patterns'));
					
					foreach( $aRemoveTitlePatterns as $sRemoveTitlePattern ) {
						$oPregMatch = @preg_match($sRemoveTitlePattern, $sSubject);
						
						if( $oPregMatch === false) {
							$this->Trace("... Invalid pattern: {$sRemoveTitlePattern}");
							break;
						}
						elseif( $oPregMatch != false ) {
							$sSubject = preg_replace($sRemoveTitlePattern, '', $sSubject);
						}
						
					}
				}
				
				$sPattern = $this->FixPattern($this->Get('title_pattern'));
				if(($sPattern != '') && (preg_match($sPattern, $sSubject, $aMatches))) {
					$this->Trace("The message '{$oEmail->sSubject}' is considered as undesired, since it could not be linked to any prior ticket despite a pattern in the subject ('{$sPattern}').");
					return (object)["bUndesired" => true, 'sPolicyId' => 'policy_ticket_unknown'];
				} 
				elseif( $oEmail->oRelatedObject != null ) {
					$this->Trace("The message '{$oEmail->sSubject}' is considered as undesired, since it could not be linked to any prior ticket despite an email header ({$oEmail->oRelatedObject}).");
					return (object)["bUndesired" => true, 'sPolicyId' => 'policy_ticket_unknown'];
				}
				
			}
		
		// ### Policy: Resolved tickets 
		$this->Trace(".. Policy: resolved tickets");
		
			if( $oTicket !== null ) {
				if( $oTicket->Get('status') == 'resolved' ) {
					switch( $this->Get('policy_ticket_resolved_behavior') ) { 
						case 'bounce_delete': 
						case 'bounce_mark_as_undesired':
						case 'delete': 
						case 'mark_as_undesired':
							$this->Trace("The message '{$oEmail->sSubject}' IS undesired, since the ticket has been resolved."); 
							return (object)["bUndesired" => true, 'sPolicyId' => 'policy_ticket_resolved'];			
							break;
							 
						case 'fallback': 
							// Reopen ticket
							$this->Trace("The message '{$oEmail->sSubject}' is NOT undesired, but ticket must be reopened."); 
							$oTicket->ApplyStimulus('ev_reopen');
							break; 
							
						default:
							// Should not happen.
							$this->Trace("Unknown action for resolved tickets.");
							break; 
						
					}
				}
			}	
		
		// ### Policy: Closed tickets
		$this->Trace(".. Policy: closed tickets");
		
			if( $oTicket !== null ) {
				if( $oTicket->Get('status') == 'closed' ) {
					switch( $this->Get('policy_ticket_closed_behavior') ) {
						case 'bounce_delete': 
						case 'bounce_mark_as_undesired':
						case 'delete': 
						case 'mark_as_undesired':
							$this->Trace("The message '{$oEmail->sSubject}' IS undesired, since the ticket has been closed."); 
							return (object)['bUndesired' => true, 'sPolicyId' => 'policy_ticket_closed'];		
							break; 
							 
						case 'fallback': 
							// Reopen ticket
							$this->Trace("The message '{$oEmail->sSubject}' is NOT undesired, but ticket must be reopened.");
							$oTicket->ApplyStimulus('ev_reopen');
							break; 
							
						default:
							// Should not happen.
							$this->Trace("Unknown action for closed tickets.");
							break; 
						
					}
				}
			}
		
		// ### Policy: Undesired patterns in subject
		$this->Trace(".. Policy: undesired patterns");
		 		
			if( $this->Get('policy_undesired_pattern_patterns') != '' ) { 
			
				// Go over each pattern and check.
				$aUndesiredSubjectPatterns = preg_split('/\\r\\n|\\r|\\n/', $this->Get('policy_undesired_pattern_patterns') ); 

				foreach($aUndesiredSubjectPatterns as $sPattern)
				{
					$oPregMatched = @preg_match($sPattern, $oEmail->sSubject);
					
					if($oPregMatched === false) {
						$this->Trace("... Invalid pattern: '{$sPattern}'");
						break;
					}
					elseif (preg_match($sPattern, $oEmail->sSubject))
					{
						$this->Trace("The message '{$oEmail->sSubject}' is considered as undesired, since it matches {$sPattern}."); 
						return (object)['bUndesired' => true, 'sPolicyId' => 'policy_undesired_pattern'];
					}
				}
			}
		 
		
		// ### Policy: Unknown caller
		$this->Trace(".. Policy: unknown caller");
		 
			$sContactQuery = 'SELECT Person WHERE email = :email';
			$oSet = new DBObjectSet(DBObjectSearch::FromOQL($sContactQuery), array(), array('email' => $oEmail->sCallerEmail));
			$sAdditionalDescription = '';
			switch($oSet->Count())
			{
				case 1:
					// Ok, the caller was found in iTop
					$this->Trace("Contact found for the email address '{$oEmail->sCallerEmail}'");
					$oCaller = $oSet->Fetch();
					break;
					
				case 0: 
					switch($this->Get('policy_unknown_caller_behavior'))
					{ 
						case 'bounce_delete': 
						case 'bounce_mark_as_undesired':
						case 'delete': 
						case 'mark_as_undesired':
							$this->Trace("No contact found for the email address '{$oEmail->sCallerEmail}', the email will not be processed"); 
							return (object)['bUndesired' => true, 'sPolicyId' => 'policy_unknown_caller'];
							break;
						
						case 'fallback':
						default:
							$this->Trace("Creating a new Person for the email: {$oEmail->sCallerEmail}");
							$oCaller = new Person();
							$oCaller->Set('email', $oEmail->sCallerEmail);
							$sDefaultValues = $this->Get('policy_unknown_caller_default_values');
							$aDefaults = explode("\n", $sDefaultValues);
							$aDefaultValues = array();
							foreach($aDefaults as $sLine)
							{
								if (preg_match('/^([^:]+):(.*)$/', $sLine, $aMatches))
								{
									$sAttCode = trim($aMatches[1]);
									$sValue = trim($aMatches[2]);
									$aDefaultValues[$sAttCode] = $sValue;
								}
							}
							$this->InitObjectFromDefaultValues($oCaller, $aDefaultValues);
							try
							{
								// Creating a CMDBChange is no longer needed in 2.0, but let's keep doing it for compatibility with 1.x
								$oMyChange = MetaModel::NewObject("CMDBChange");
								$oMyChange->Set("date", time());
								$sUserString = CMDBChange::GetCurrentUserName();
								$oMyChange->Set("userinfo", $sUserString);
								$iChangeId = $oMyChange->DBInsert();
								$oCaller->DBInsertTracked($oMyChange);					
							}
							catch(Exception $e)
							{
								// This is an actual error.
								$this->Trace("Failed to create a Person for the email address '{$oEmail->sCallerEmail}'.");
								$this->Trace($e->getMessage());
								$this->HandleError($oEmail, 'failed_to_create_contact', $oEmail->oRawEmail);
								return null;
							}
						
					}			
					break;
				
				default:
					$this->Trace("Found {$oSet->Count()} callers with the same email address '{$oEmail->sCallerEmail}.', the first one will be used.");
					// Multiple callers with the same email address !!!
					$oCaller = $oSet->Fetch();
			}
		
		// End of checking if ticket is compliant with policies.  
		 
		
		return (object)[
			'bUndesired' => false,
			'oCaller' => $oCaller 
		];
		
		
	}

	/**
	 * Make sure that the given string is a proper PCRE pattern by surrounding
	 * it with slashes, if needed
	 * @param string $sPattern The pattern to check (can be an empty string)
	 * @return string The valid pattern (or an empty string)
	 */
	protected function FixPattern($sPattern)
	{
		$sReturn = $sPattern;
		if ($sPattern != '')
		{
			$sFirstChar = substr($sPattern, 0, 1);
			$sLastChar = substr($sPattern, -1, 1);
			if (($sFirstChar != $sLastChar) || preg_match('/[0-9A-Z-a-z]/', $sFirstChar) || preg_match('/[0-9A-Z-a-z]/', $sLastChar))
			{
				// Missing delimiter patterns
				$sReturn = '/'.$sPattern.'/';
			}
		}
		return $sReturn;
	}

	/**
	 * Replace variables in a string with info from incoming EmailMessage 
	 * @param string $sString The string to work with
	 * @param string $oEmail The Email Message to derive from
	 * @return string The string 
	 */
	protected function ReplaceMailVariables($sString, EmailMessage $oEmail )
	{	
		// Could be extended with properties from EmailMessage class 
		
		// No double quotes here (otherwise $mail is interpreted as a PHP object)	
		// Patch string (html in body) 
		$sString = str_ireplace('$mail-&gt;', '$mail->', $sString);
		
		$aFind = [
			'$mail->UIDL',
			'$mail->MessageId', 
			'$mail->Subject',
			'$mail->CallerEmail',
			'$mail->CallerName',
			'$mail->Recipient',
			'$mail->Date',
			'$mail->BodyTextPlain',
			'$mail->BodyText',
			'$mail->BodyFormat'
		];
		
		$aReplacement = [
			$oEmail->sUIDL,
			$oEmail->sMessageId,
			$oEmail->sSubject,
			$oEmail->sCallerEmail,
			$oEmail->sCallerName,
			$oEmail->sRecipient,
			$oEmail->sDate,
			strip_tags($oEmail->sBodyText), 
			$oEmail->sBodyText,
			$oEmail->sBodyFormat 
		]; 
		 
		// Let's not be picky (case insensitive ok)
		// For some reason, it stays case sensitive?
		$sString = str_ireplace($aFind, $aReplacement, $sString);
		
		return $sString; 
		
	}

}
//
// Menus
//
class MenuCreation_jb_itop_standard_email_synchro extends ModuleHandlerAPI
{
	public static function OnMenuCreation()
	{
		global $__comp_menus__; // ensure that the global variable is indeed global !
		$__comp_menus__['AdminTools'] = new MenuGroup('AdminTools', 80 , null, UR_ACTION_MODIFY, UR_ALLOWED_YES, null);
		if (UserRights::IsAdministrator())
		{
			$__comp_menus__['MailInboxes'] = new OQLMenuNode('MailInboxes', "SELECT MailInboxStandard", $__comp_menus__['AdminTools']->GetIndex(), 20, true , null, UR_ACTION_MODIFY, UR_ALLOWED_YES, null, true);
		}
	}
} // class MenuCreation_jb_itop_standard_email_synchro
