<?php

// PHP Data Model definition file

// WARNING - WARNING - WARNING
// DO NOT EDIT THIS FILE (unless you know what you are doing)
//
// If you use supply a datamodel.xxxx.xml file with your module
// the this file WILL BE overwritten by the compilation of the
// module (during the setup) if the datamodel.xxxx.xml file
// contains the definition of new classes or menus.
//
// The recommended way to define new classes (for iTop 2.0) is via the XML definition.
// This file remains in the module's template only for the cases where there is:
// - either no new class or menu defined in the XML file
// - or no XML file at all supplied by the module

class izLeisureTime implements iApplicationObjectExtension {
	
	 
	
	
	// public function OnUpdate( $oObject, $aChanges ) is AFTER updating
	
		/**
	 *	Invoked to determine whether an object can be written to the database 
	 *	
	 *	The GUI calls this verb and reports any issue.
	 *	Anyhow, this API can be called in other contexts such as the CSV import tool.
	 * 
	 * @param DBObject $oObject The target object
	 * @return string[] A list of errors message. An error message is made of one line and it can be displayed to the end-user.
	 */	
	public function OnCheckToWrite( $oObject ) {
		
		if( $oObject instanceof LeisurePass ) {
			 		
			// For easy reference
			$oPass = $oObject;
			
			// Not creating; so only on modifying a pass
			// On creating in the regular way:
			// On creating from a select box: no value.
			if( intval( $oPass->Get('id') ) > 1 ) {
			 
				
				$sOQL = 'SELECT LeisureCheck WHERE pass_id = '. $oPass->Get('id');			
				$oPassChildChecksSet = new DBObjectSet(DBObjectSearch::FromOQL($sOQL));
							
				// Now we should retrieve all checks for this pass
				$iAmount = 0;
				while($oCheck = $oPassChildChecksSet->Fetch())
				{
					$iAmount = $iAmount + $oCheck->Get('value');
				}
				
				
				$sOQL = 'SELECT LeisurePassCategory WHERE id = '. $oPass->Get('category_id');			
				$oPassCategorySet = new DBObjectSet(DBObjectSearch::FromOQL($sOQL));
						
				// There will only be one
				while($oPassCategory = $oPassCategorySet->Fetch())
				{
					$iMaxAmount = $oPassCategory->Get('value');
				}
				
				
				// Amount of checks should NOT be higher than the value of the pass
				if( $iAmount > $iMaxAmount ) {
					return Array( 
						Dict::S('Errors/LeisurePass/ValueOfChecksTooHigh')." ( ". $iAmount . " / " . $iMaxAmount . " )"
					);
				}
			
			}
			
			// In any case: there should only be one pass per year per person		
			$sOQL = "SELECT LeisurePass WHERE person_id = ". $oPass->Get('person_id')." AND DATE_FORMAT(created, '%Y')";			
			$oPassesThisYear = new DBObjectSet(DBObjectSearch::FromOQL($sOQL));
			
			if( $oPassesThisYear->countExceeds(0) == true ) {
				return Array( 
					Dict::S('Errors/LeisurePass/OnePassPerYear')." ( ". $iAmount . " / " . $iMaxAmount . " )"
				);		
			
			}
			
			
		}
		
		
		elseif( $oObject instanceof LeisureCheck ) {
			
			// user should not be able to create a new pass ( $oObject->Value ) if the TOTAL Value of previous checks AND this new one is bigger than the category of the pass
			
			$oCheck = $oObject; // to make it easier to read the code
			
			// Get all existing checks (could include this one if it's being modified)
			$sOQL = 'SELECT LeisureCheck WHERE pass_id = '. $oCheck->Get('pass_id');			
			$oPassChildChecksSet = new DBObjectSet(DBObjectSearch::FromOQL($sOQL));
			
			
			// Get pass
			$sOQL = 'SELECT LeisurePass WHERE id = '. $oCheck->Get('pass_id');			
			$oPasses = new DBObjectSet(DBObjectSearch::FromOQL($sOQL));

			
			$iAmount = 0;
			
			// We should retrieve 1 pass		
			while($oPassCurrent = $oPasses->Fetch())
			{ 
				$oPass = $oPassCurrent;
			}
			
			// Now we should retrieve all checks for this pass
			while($oExistingCheck = $oPassChildChecksSet->Fetch())
			{
				$iAmount = $iAmount + $oExistingCheck->Get('value');
			}
			
			// New check? If so, add it, since it won't be i nour $oPassChildChecksSet
			if( intval($oCheck->Get('id')) < 1 ) {
				$iAmount = $iAmount + $oCheck->Get('value');				
			}
			
			// Get value of pass
			$sOQL = 'SELECT LeisurePassCategory WHERE id = '. $oPass->Get('category_id');			
			$oPassCategorySet = new DBObjectSet(DBObjectSearch::FromOQL($sOQL));
					
			// There will only be one
			while($oPassCategory = $oPassCategorySet->Fetch())
			{
				$iMaxAmount = $oPassCategory->Get('value');
			}
			
			// Amount of previous checks AND the new one must be smaller than the total value (category) of the pass
			if( $iAmount > $iMaxAmount ) {
				return Array( 
					Dict::S('Errors/LeisurePass/ValueOfChecksTooHigh')." ( ". ($iAmount + $oCheck->Get('value')). " / " . $iMaxAmount  . " )"
				);
			}
			
		}
		
		// No errors		
		return Array();
		
	}
	
	
	
		/**
	 *	Invoked to determine whether an object has been modified in memory
	 *
	 *	The GUI calls this verb to determine the message that will be displayed to the end-user.
	 *	Anyhow, this API can be called in other contexts such as the CSV import tool.
	 *	
	 * If the extension returns false, then the framework will perform the usual evaluation.
	 * Otherwise, the answer is definitively "yes, the object has changed".	 	 	 
	 *	 
	 * @param DBObject $oObject The target object
	 * @return boolean True if something has changed for the target object
	 */	
	public function OnIsModified($oObject) {
		return false;
	}
 

	/**
	 *	Invoked to determine whether an object can be deleted from the database
	 *	
	 * The GUI calls this verb and stops the deletion process if any issue is reported.
	 * 	 
	 * Please not that it is not possible to cascade deletion by this mean: only stopper issues can be handled. 	 
	 * 
	 * @param DBObject $oObject The target object
	 * @return string[] A list of errors message. An error message is made of one line and it can be displayed to the end-user.
	 */	
	public function OnCheckToDelete($oObject) {
		return Array();
		
	}

	/**
	 *	Invoked when an object is updated into the database
	 *	
	 * The method is called right <b>after</b> the object has been written to the database.
	 * 
	 * @param DBObject $oObject The target object
	 * @param CMDBChange|null $oChange A change context. Since 2.0 it is fine to ignore it, as the framework does maintain this information once for all the changes made within the current page
	 * @return void
	 */	
	public function OnDBUpdate($oObject, $oChange = null)  {
		return;
	}

	/**
	 *	Invoked when an object is created into the database
	 *	
	 * The method is called right <b>after</b> the object has been written to the database.
	 * 
	 * @param DBObject $oObject The target object
	 * @param CMDBChange|null $oChange A change context. Since 2.0 it is fine to ignore it, as the framework does maintain this information once for all the changes made within the current page
	 * @return void
	 */	
	public function OnDBInsert($oObject, $oChange = null) {
		return;
	}

	/**
	 *	Invoked when an object is deleted from the database
	 *	
	 * The method is called right <b>before</b> the object will be deleted from the database.
	 * 
	 * @param DBObject $oObject The target object
	 * @param CMDBChange|null $oChange A change context. Since 2.0 it is fine to ignore it, as the framework does maintain this information once for all the changes made within the current page
	 * @return void
	 */	
	public function OnDBDelete($oObject, $oChange = null) {
		return;
	}
	
	 
	
	
	
}


